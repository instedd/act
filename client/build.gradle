/*
 * This build file was auto generated by running the Gradle 'init' task
 * by 'mgarcia' at '10/21/14 5:35 PM' with Gradle 2.1
 *
 * This generated file contains a sample Groovy project to get you started.
 * For more details take a look at the Groovy Quickstart chapter in the Gradle
 * user guide available at http://gradle.org/docs/2.1/userguide/tutorial_groovy_projects.html
 */

// Apply the groovy plugin to add support for Groovy
apply plugin: 'groovy'
apply plugin: 'eclipse'
apply plugin: 'application'

// In this section you declare where to find the dependencies of your project
repositories {
    // Use 'jcenter' for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

// In this section you declare the dependencies for your production and test code
dependencies {
    // We use the latest groovy 2.x version for building this library
    compile 'org.codehaus.groovy:groovy-all:2.3.6'

    // We use the awesome Spock testing and specification framework
    testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
    testCompile 'junit:junit:4.11'
    compile group: 'com.google.guava', name: 'guava', version: '12.0'
    compile group: 'com.google.inject', name: 'guice', version: '3.0'
	compile group: 'ch.qos.logback', name: 'logback-classic', version: '1.1.2'
    compile 'org.codehaus.groovy.modules.http-builder:http-builder:0.7'
	compile 'org.xerial:sqlite-jdbc:3.7.2'
	compile ('io.reactivex:rxjava:1.0.2') 
	compile 'commons-io:commons-io:2.4'
}

mainClassName = "org.instedd.act.App"
def version = "development-${"git rev-parse --verify --short HEAD".execute().text.trim()}"
println "Version ${version}"



task makeBuildDir {
    description 'Makes build directory ./build'
} << {
    buildDir.mkdirs()
}

String getViVersion(String version) {
    if(version.startsWith("development")) {
        return "0.0.0.0"
    }
    def components = (version =~ /\d+(?:\.\d+)+/)[0].split(/\./) as List
    components += (["0"] * (4-components.size()))
    return components.join('.')
}

task downloadWinrun4j (dependsOn: 'makeBuildDir') << {
    def filename = "winrun4J-0.4.5.zip"
    def url = "https://www.dropbox.com/s/j7z19jksvrjy5mg/winrun4J-0.4.5.zip?dl=1"
    def zipFile = new File(buildDir, filename)
    def zipDest = new File(buildDir, "winrun4j")
    if (!buildDir.exists()) {
        mkdir buildDir
    }
    println "Downloading ${filename} from ${url} to ${zipDest}..."
    
    ant.get(src: url, dest: zipFile, skipexisting: true, verbose: true)
    delete zipDest
    ant.unzip(src: zipFile, dest: zipDest)
}

task downloadJre (dependsOn: 'makeBuildDir') {
} << {
    def filename
    filename = "jre-7u72-windows-i586.gz"
    def url = "https://www.dropbox.com/s/giwqqcjn6uh5p9l/jre-7u72-windows-i586.gz?dl=1"

    def tgzFile = new File(buildDir, filename)
    println "Downloading ${filename} from ${url} to ${tgzFile}..."
    
    ant.get(src: url, dest: tgzFile, skipexisting: true, verbose: true)

    ext.jrePackage = tgzFile
}

task downloadRsync (dependsOn: 'makeBuildDir') << {
    def filename = "cwRsync.zip"
    def url = "https://www.dropbox.com/s/io2ply67jrx1niv/cwRsync.zip?dl=1"
    def zipFile = new File(buildDir, filename)
    def zipDest = new File(buildDir, "cwRsync")
    if (!buildDir.exists()) {
        mkdir buildDir
    }
    println "Downloading ${filename} from ${url} to ${zipDest}..."
    
    ant.get(src: url, dest: zipFile, skipexisting: true, verbose: true)
    delete zipDest
    ant.unzip(src: zipFile, dest: zipDest)
}

task prepareNsis {
    dependsOn cleanInstallApp
    dependsOn installApp
    dependsOn downloadWinrun4j
    dependsOn downloadRsync

    try {
        def proc = ['which', 'makensis'].execute()
        proc.waitFor()
        ext.makensisPath = proc.in.text.trim()
    } catch (e) {
        println "Error finding makensis: ${e.message}"
        ext.makensisPath = null
    }
} << {
    def workDir = installApp.destinationDir

    copy {
        from file("dist/license.txt")
        into workDir
    }
    copy {
        from file("${buildDir}/winrun4j/winrun4j/bin/WinRun4J.exe")
        from file("${buildDir}/winrun4j/winrun4j/bin/RCEDIT.exe")
        
        into "${workDir}/bin"
    }
    copy {
        from file("dist/nsis/plugins/ExecDos.dll")
        into "${workDir}/nsis"
    }
    copy {
        from "${buildDir}/cwRsync/cwRsync/bin/"
        into "${workDir}/cwRsync"
    }
}

task installer {
    dependsOn prepareNsis
    dependsOn downloadJre
    description "Create an installer using NSIS"
} << {
    def platform = "win32" // TODO: support win64
    def workDir = installApp.destinationDir
    def distDir = new File(buildDir, "distributions")
    def nsiScriptName = "installer.nsi"
    def nsisOutput = "ACT-${platform}-${version}.exe"
    def installerFile = nsisOutput 

    if (prepareNsis.makensisPath.empty) {
        println "warning: makensis not found in your system"
        return
    }

    copy {
        from file("dist/act-client.ini")
        into "${workDir}/bin/"
    }

    copy {
        from file("json/locations-packed.json")
        into workDir
    }

    println "Creating installer..."
    copy {
        from file(nsiScriptName)
        into workDir
    }
    delete file("${workDir}/jre1.7.0_71")
    copy {
        from tarTree(resources.gzip(downloadJre.jrePackage))
        into workDir
    }

    def nsisParams = [prepareNsis.makensisPath, "-V2", "-DVERSION=${version}", "-DVIVERSION=${getViVersion(version)}", "-DPLATFORM=${platform}"]

    nsisParams.add(file("${workDir}/${nsiScriptName}"))
    println nsisParams
    def nsisProc = nsisParams.execute()
    nsisProc.waitFor()
    println nsisProc.text
    println "Check ${workDir}/${nsisOutput}"
    if (nsisProc.exitValue() != 0) {
        throw new RuntimeException("makensis failed")
    }

    copy {
        from file("${workDir}/${nsisOutput}")
        into distDir
        rename nsisOutput, installerFile
    }
    println "Created installer is in ${distDir}/${installerFile}"
}